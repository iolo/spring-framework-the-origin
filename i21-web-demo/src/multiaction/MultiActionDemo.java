package multiaction;

import java.io.IOException;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.interface21.web.servlet.ModelAndView;
import com.interface21.web.servlet.mvc.multiaction.MultiActionController;

/**
 * Request handling methods in this class are invoked by
 * name. See page 484- for a discussion of the required signatures
 * and return type.
 * 
 * There is also an exception handling and LastModified
 * (HTTP caching) capability in the MultiActionController 
 * framework superclass.
 * 
 * @author Rod Johnson
 */
public class MultiActionDemo extends MultiActionController {
	
	/**
	 * Demonstrates a simple request handling method.
	 */
	public ModelAndView handleDebugRequest(HttpServletRequest request, HttpServletResponse response) {
		System.out.println("in handleDebugRequest");
		return new ModelAndView("debugView");
	}


	/**
	* This controller method shows how any controller
	* can build the request itself, if it returns null.
	* Of course, usually it's best to let a view handle 
	* result generation--using a view gives us an extra
	* level of indirection that is often useful.
	*/
	public ModelAndView buildResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {
		System.out.println("in buildResponse");
		
		ServletOutputStream sos = response.getOutputStream();
		
		sos.println("This response was generated by the controller " +
				this + ".<br> As we normally don't want to generate " +					"content in Java classes, this is an unusual special case. " +					"It's most appropriate for some binary formats. " +					"<br>When we want to build the response in a controller, " +					"we return null. This works for ordinary controllers and" +					"MultiActionControllers.");
		sos.close();
		
		// Return value of null will let the controller know
		// that this controller built the response itself
		return null;
	}

}
